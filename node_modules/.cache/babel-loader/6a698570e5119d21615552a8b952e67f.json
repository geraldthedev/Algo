{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// This is a utility class that makes it easier to work with asynchronous tasks.\n// Here's why I don't just use Promises:\n// (a) I don't want to depend on a Promise implementation.\n// (b) Promises aren't cancellable (yet?), and I want cancellability.\n//\n// This is very stripped down, compared to Promises.\n// (a) You can only call .thenDo() once. Because there's only one party waiting\n//     on the result of a task, cancelling always propagates backwards.\n// (b) The argument to .thenDo() must return either undefined or a Task. I don't\n//     promote values to Tasks, like what happens with Promises.\nvar Task = exports;\n/**\n * Creates a Task.\n *\n * The `doSomething` function is called immediately, so that it can start\n * whatever work is part of this task.\n *\n * The `doSomething` function is given a resolve function and a reject function,\n * and it should call one of them when the task is finished, to report its\n * result.\n *\n * The `doSomething` function can optionally return a cancel function. This will\n * be called if the task is cancelled.\n *\n * @param  {function(function(T), function(?)): function()} doSomething\n * @return {Task<T>}\n * @template T\n */\n\nTask.start = function (doSomething) {\n  var me = {}; // onFinish should be called as soon as both finished and onFinish are\n  // defined. It should be called by the piece of code that just defined either\n  // finished or onFinish.\n\n  var finished;\n  var onFinish;\n  var cleaners = [];\n\n  function finish(err, result) {\n    if (!finished) {\n      finished = {\n        err: err,\n        result: result\n      };\n\n      if (onFinish) {\n        onFinish(); // To prevent memory leaks, delete our reference to onFinish after\n        // calling it.\n\n        onFinish = function onFinish() {};\n      }\n\n      var cleanup;\n\n      while (cleanup = cleaners.pop()) {\n        cleanup();\n      }\n\n      if (err === 'cancelled') {\n        if (abort) abort();\n      }\n\n      abort = null;\n    }\n  }\n\n  try {\n    // doSomething must be called immediately.\n    var abort = doSomething(function (result) {\n      finish(null, result);\n    }, function (err) {\n      finish(err, null);\n    });\n  } catch (err) {\n    finish(err, null);\n  }\n  /**\n   * Cancels the task (unless the task has already finished, in which case\n   * this call is ignored).\n   *\n   * Subsequent tasks created with #thenDo will not be started. However, clean-\n   * up code added with #finished will run.\n   */\n\n\n  me.cancel = function () {\n    finish('cancelled', null);\n  };\n  /**\n   * Sets the listener that will be called with the result of this task, when\n   * finished. This function can be called at most once.\n   *\n   * @param {function(?, T)} callback\n   */\n\n\n  function setListener(callback) {\n    if (onFinish) {\n      throw new Error('thenDo/finally called more than once');\n    }\n\n    if (finished) {\n      onFinish = function onFinish() {};\n\n      callback(finished.err, finished.result);\n    } else {\n      onFinish = function onFinish() {\n        callback(finished.err, finished.result);\n      };\n    }\n  }\n  /**\n   * Creates and returns a composite task, consisting of this task and a\n   * subsequent task.\n   *\n   * @param {function(T): ?Task<U>} onResolve A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the result of this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @param {function(?): ?Task<U>} onReject A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the error produced by this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @return {Task<U>} The composite task. Cancelling the composite task cancels\n   *     either this task or the subsequent task, depending on whether this\n   *     task is finished.\n   * @template U\n   */\n\n\n  me.thenDo = function (onResolve, onReject) {\n    return compose(me, setListener, onResolve, onReject);\n  };\n  /**\n   * Registers a cleanup function, that will be run when the task finishes,\n   * regardless of error or cancellation.\n   *\n   * @param {function()} cleanup\n   * @return {THIS}\n   */\n\n\n  me.finally = function (cleanup) {\n    if (!finished) {\n      cleaners.push(function () {\n        process.nextTick(cleanup);\n      });\n    } else {\n      process.nextTick(cleanup);\n    }\n\n    return me;\n  };\n\n  return me;\n};\n/**\n * Creates a Task with the given result.\n */\n\n\nTask.withValue = function (result) {\n  return Task.start(function (resolve) {\n    resolve(result);\n  });\n};\n/**\n * Creates a Task with the given error.\n */\n\n\nTask.withError = function (err) {\n  return Task.start(function (resolve, reject) {\n    reject(err);\n  });\n};\n/**\n * Returns a new task that races the given tasks. Eventually finishes with the\n * result or error of whichever task finishes first. If any task is cancelled,\n * all of the tasks are cancelled.\n *\n * @param {Array<Task<T>>} tasks\n * @return {Task<T>}\n * @template T\n */\n\n\nTask.race = function (tasks) {\n  return Task.start(function (resolve, reject) {\n    function cancelAll() {\n      tasks.forEach(function (task) {\n        task.cancel();\n      });\n    }\n\n    tasks.forEach(function (task) {\n      task.finally(cancelAll).thenDo(resolve, reject);\n    });\n    return cancelAll;\n  });\n};\n/**\n * Creates a composite task, which uses the output of the first task to create\n * a subsequent task, and represents the two tasks together.\n *\n * This function is internal-only. It is used by Task.thenDo().\n *\n * @param {Task<T>} firstTask\n * @param {function(function(?, T))} whenFirstTaskFinishes The private\n *     setListener method on the firstTask.\n * @param {function(T): Task<U>} onResolve\n * @param {function(?): Task<U>} onReject\n * @return {Task<U>}\n * @template T, U\n */\n\n\nfunction compose(firstTask, whenFirstTaskFinishes, onResolve, onReject) {\n  return Task.start(function (resolve, reject) {\n    var cancelled;\n    var currentTask = firstTask;\n    whenFirstTaskFinishes(function (err, result) {\n      currentTask = null; // createSubsequentTask must be called asynchronously.\n\n      process.nextTick(function () {\n        if (cancelled || err === 'cancelled') {\n          return reject('cancelled');\n        } // Start the subsequent task.\n\n\n        if (err == null) {\n          if (!onResolve) {\n            return resolve(result);\n          }\n\n          try {\n            currentTask = onResolve(result);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } else {\n          if (!onReject) {\n            return reject(err);\n          }\n\n          try {\n            currentTask = onReject(err);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } // Was a subsequent task returned?\n\n\n        if (!currentTask) {\n          return resolve(undefined);\n        }\n\n        currentTask.thenDo(resolve, reject);\n      });\n    });\n    return function cancelCompositeTask() {\n      cancelled = true;\n\n      if (currentTask) {\n        currentTask.cancel();\n      }\n    };\n  });\n}","map":null,"metadata":{},"sourceType":"script"}