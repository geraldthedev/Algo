{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n;\n/**\n * Polyline encodes an array of LatLng objects.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.encodePath\n * @function\n * @param {LatLng[]} path\n * @return {string}\n */\n\nexports.encodePath = function (path) {\n  var result = [];\n  var start = [0, 0];\n  var end;\n\n  var encodePart = function encodePart(part) {\n    part = part < 0 ? ~(part << 1) : part << 1;\n\n    while (part >= 0x20) {\n      result.push(String.fromCharCode((0x20 | part & 0x1f) + 63));\n      part >>= 5;\n    }\n\n    result.push(String.fromCharCode(part + 63));\n  };\n\n  for (var i = 0, I = path.length || 0; i < I; ++i) {\n    end = [Math.round(path[i].lat * 1e5), Math.round(path[i].lng * 1e5)];\n    encodePart(end[0] - start[0]); // lat\n\n    encodePart(end[1] - start[1]); // lng\n\n    start = end;\n  }\n\n  return result.join('');\n};\n/**\n * Decodes a polyline encoded string.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.decodePath\n * @function\n * @param {string} path\n * @return {LatLng[]}\n */\n\n\nexports.decodePath = function (encodedPath) {\n  var len = encodedPath.length || 0;\n  var path = new Array(Math.floor(encodedPath.length / 2));\n  var index = 0;\n  var lat = 0;\n  var lng = 0;\n\n  for (var pointIndex = 0; index < len; ++pointIndex) {\n    var result = 1;\n    var shift = 0;\n    var b;\n\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n\n    lat += result & 1 ? ~(result >> 1) : result >> 1;\n    result = 1;\n    shift = 0;\n\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n\n    lng += result & 1 ? ~(result >> 1) : result >> 1;\n    path[pointIndex] = {\n      lat: lat * 1e-5,\n      lng: lng * 1e-5\n    };\n  }\n\n  path.length = pointIndex;\n  return path;\n};\n\nexports.placesAutoCompleteSessionToken = require('uuid/v4');","map":null,"metadata":{},"sourceType":"script"}