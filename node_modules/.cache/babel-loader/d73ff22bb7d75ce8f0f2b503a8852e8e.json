{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar url = require('url');\n\nvar Task = require('./task');\n\nexports.inject = function (options) {\n  var key = options.key || process.env.GOOGLE_MAPS_API_KEY;\n  var channel = options.channel;\n  var clientId = options.clientId || process.env.GOOGLE_MAPS_API_CLIENT_ID;\n  var clientSecret = options.clientSecret || process.env.GOOGLE_MAPS_API_CLIENT_SECRET;\n  var rate = options.rate || {};\n  var rateLimit = rate.limit || 50; // 50 requests per ratePeriod.\n\n  var ratePeriod = rate.period || 1000; // 1 second.\n\n  var makeUrlRequest = options.makeUrlRequest || require('./make-url-request');\n\n  var mySetTimeout = options.setTimeout || setTimeout;\n  var myClearTimeout = options.clearTimeout || clearTimeout;\n\n  var getTime = options.getTime || function () {\n    return new Date().getTime();\n  };\n\n  var wait = require('./wait').inject(mySetTimeout, myClearTimeout);\n\n  var attempt = require('./attempt').inject(wait).attempt;\n\n  var ThrottledQueue = require('./throttled-queue').inject(wait, getTime);\n\n  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);\n  /**\n   * Makes an API request using the injected makeUrlRequest.\n   *\n   * Inserts the API key (or client ID and signature) into the query\n   * parameters. Retries requests when the status code requires it.\n   * Parses the response body as JSON.\n   *\n   * The callback is given either an error or a response. The response\n   * is an object with the following entries:\n   * {\n   *   status: number,\n   *   body: string,\n   *   json: Object\n   * }\n   *\n   * @param {string} path\n   * @param {Object} query This function mutates the query object.\n   * @param {Function} callback\n   * @return {{\n   *   cancel: function(),\n   *   finally: function(function()),\n   *   asPromise: function(): Promise\n   * }}\n   */\n\n  return function (path, query, callback) {\n    callback = callback || function () {};\n\n    var retryOptions = query.retryOptions || options.retryOptions || {};\n    delete query.retryOptions;\n    var timeout = query.timeout || options.timeout || 60 * 1000;\n    delete query.timeout;\n    var useClientId = query.supportsClientId && clientId && clientSecret;\n    delete query.supportsClientId;\n    var queryOptions = query.options || {};\n    delete query.options;\n    var isPost = queryOptions.method === 'POST';\n    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);\n\n    if (isPost) {\n      queryOptions.body = query;\n    } // Determines whether a response indicates a retriable error.\n\n\n    var canRetry = queryOptions.canRetry || function (response) {\n      return response == null || response.status === 500 || response.status === 503 || response.status === 504 || response.json && (response.json.status === 'OVER_QUERY_LIMIT' || response.json.status === 'RESOURCE_EXHAUSTED');\n    };\n\n    delete queryOptions.canRetry; // Determines whether a response indicates success.\n\n    var isSuccessful = queryOptions.isSuccessful || function (response) {\n      return response.status === 200 && (response.json == undefined || response.json.status === undefined || response.json.status === 'OK' || response.json.status === 'ZERO_RESULTS');\n    };\n\n    delete queryOptions.isSuccessful;\n\n    function rateLimitedGet() {\n      return requestQueue.add(function () {\n        return Task.start(function (resolve, reject) {\n          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);\n        });\n      });\n    }\n\n    var timeoutTask = wait(timeout).thenDo(function () {\n      throw 'timeout';\n    });\n    var requestTask = attempt({\n      'do': rateLimitedGet,\n      until: function until(response) {\n        return !canRetry(response);\n      },\n      interval: retryOptions.interval,\n      increment: retryOptions.increment,\n      jitter: retryOptions.jitter\n    });\n    var task = Task.race([timeoutTask, requestTask]).thenDo(function (response) {\n      // We add the request url and the original query to the response\n      // to be able to use them when debugging errors.\n      response.requestUrl = requestUrl;\n      response.query = query;\n\n      if (isSuccessful(response)) {\n        return Task.withValue(response);\n      } else {\n        return Task.withError(response);\n      }\n    }).thenDo(function (response) {\n      callback(null, response);\n    }, function (err) {\n      callback(err);\n    });\n\n    if (options.Promise) {\n      var originalCallback = callback;\n      var promise = new options.Promise(function (resolve, reject) {\n        callback = function callback(err, result) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n\n          originalCallback(err, result);\n        };\n      });\n\n      task.asPromise = function () {\n        return promise;\n      };\n    }\n\n    delete task.thenDo;\n    return task;\n  };\n  /**\n   * Adds auth information to the query, and formats it into a URL.\n   * @param {string} path\n   * @param {Object} query\n   * @param {boolean} useClientId\n   * @return {string} The formatted URL.\n   */\n\n  function formatRequestUrl(path, query, useClientId) {\n    if (channel) {\n      query.channel = channel;\n    }\n\n    if (useClientId) {\n      query.client = clientId;\n    } else if (key && key.indexOf('AIza') == 0) {\n      query.key = key;\n    } else {\n      throw 'Missing either a valid API key, or a client ID and secret';\n    }\n\n    var requestUrl = url.format({\n      pathname: path,\n      query: query\n    }); // When using client ID, generate and append the signature param.\n\n    if (useClientId) {\n      var secret = new Buffer(clientSecret, 'base64');\n      var payload = url.parse(requestUrl).path;\n      var signature = computeSignature(secret, payload);\n      requestUrl += '&signature=' + encodeURIComponent(signature);\n    }\n\n    return requestUrl;\n  }\n  /**\n   * @param {string} secret\n   * @param {string} payload\n   * @return {string}\n   */\n\n\n  function computeSignature(secret, payload) {\n    var signature = new Buffer(require('crypto').createHmac('sha1', secret).update(payload).digest('base64')).toString().replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n    while (signature.length % 4) {\n      signature += '=';\n    }\n\n    return signature;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}